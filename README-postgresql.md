# PostgreSQL Database Setup

This project uses PostgreSQL for production and H2 for local development.

## Configuration

### Environment Variables

Copy the `.env.example` file to `.env` and adjust the values as needed:

```bash
cp .env.example .env
```

Default variables:
- `DB_HOST`: PostgreSQL host (default: localhost)
- `DB_PORT`: PostgreSQL port (default: 5432)
- `DB_NAME`: Database name (default: newsletter)
- `DB_USER`: Database user (default: postgres)
- `DB_PASSWORD`: Database password (default: postgres)
- `SPRING_PROFILES_ACTIVE`: Spring profile to use (dev, prod)

### Spring Profiles

- `dev`: Uses H2 in-memory database
- `prod`: Uses PostgreSQL database

## Running PostgreSQL

### Using Docker Compose

```bash
# Start PostgreSQL only
docker-compose -f docker-compose.postgresql.yml up -d

# Or start with the main docker-compose file
docker-compose up -d
```

### Accessing PostgreSQL

```bash
# Connect to PostgreSQL using psql
docker exec -it newsletter-postgres psql -U postgres -d newsletter
```

### H2 Console (Development)

When running with the `dev` profile, the H2 console is available at:

```
http://localhost:8080/h2-console
```

Connection details:
- JDBC URL: `jdbc:h2:mem:newsletter`
- User Name: `sa`
- Password: (empty)

## Database Schema

The schema is managed using Flyway migrations. The initial schema is defined in:

```
external/src/main/resources/db/migration/V1__create_tables.sql
```

### Tables

- `users`: User information with device tokens
- `categories`: Content categories
- `reserved_keywords`: Approved keywords
- `candidate_keywords`: Keywords pending approval
- `contents`: Content information with MongoDB references
- `summaries`: Content summaries
- `category_keyword_mappings`: Mapping between categories and keywords with weights
- `keyword_mappings`: Mapping between reserved and candidate keywords (automatically generated by @ManyToMany relationship)
- `content_keyword_mappings`: Mapping between content and keywords

### Entity Relationships

- `ReservedKeyword` and `CandidateKeyword` have a ManyToMany relationship
  - This is implemented using JPA's `@ManyToMany` annotation
  - The join table `keyword_mappings` is automatically generated
  - When a candidate keyword is approved, it is removed and its name is used to create or find a reserved keyword 